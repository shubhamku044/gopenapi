// models.go - Generates Go structs from OpenAPI schemas
package generator

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/shubhamku044/gopenapi/internal/parser"
)

// ModelGenerator generates Go structs from OpenAPI schemas
type ModelGenerator struct {
	Config        Config
	SchemasByName map[string]parser.Schema
}

// ModelFile represents a generated model file
type ModelFile struct {
	Name        string
	PackageName string
	Imports     []string
	Models      []Model
}

// Model represents a Go struct to be generated
type Model struct {
	Name        string
	Description string
	Fields      []Field
}

// Field represents a struct field
type Field struct {
	Name        string
	Type        string
	JSONName    string
	Description string
	Required    bool
	Example     interface{}
}

// NewModelGenerator creates a new model generator
func NewModelGenerator(config Config) *ModelGenerator {
	return &ModelGenerator{
		Config:        config,
		SchemasByName: make(map[string]parser.Schema),
	}
}

// GenerateModels generates Go struct models from OpenAPI schemas
func (g *ModelGenerator) GenerateModels(spec *parser.OpenAPISpec) ([]OutputFile, error) {
	var files []OutputFile

	// Collect all schemas from components
	for name, schema := range spec.Components.Schemas {
		g.SchemasByName[name] = schema
	}

	// Group models by file
	modelsByFile := make(map[string][]Model)

	// Process each schema
	for name, schema := range g.SchemasByName {
		model, err := g.generateModel(name, schema)
		if err != nil {
			return nil, fmt.Errorf("error generating model for %s: %w", name, err)
		}

		// Group models by file (one file per model for simplicity)
		fileName := strings.ToLower(name) + ".go"
		modelsByFile[fileName] = append(modelsByFile[fileName], model)
	}

	// Create a file for each group of models
	for fileName, models := range modelsByFile {
		modelFile := ModelFile{
			Name:        fileName,
			PackageName: "models",
			Models:      models,
		}

		// Add imports based on field types
		modelFile.Imports = g.determineImports(models)

		// Generate the file content
		content, err := g.renderModelFile(modelFile)
		if err != nil {
			return nil, fmt.Errorf("error rendering model file %s: %w", fileName, err)
		}

		files = append(files, OutputFile{
			Path:    "api/models/" + fileName,
			Content: content,
		})
	}

	return files, nil
}

// generateModel generates a Go struct model from an OpenAPI schema
func (g *ModelGenerator) generateModel(name string, schema parser.Schema) (Model, error) {
	model := Model{
		Name:        formatModelName(name),
		Description: schema.Description,
		Fields:      []Field{},
	}

	// Process all properties
	for propName, propSchema := range schema.Properties {
		field := Field{
			Name:        formatFieldName(propName),
			Type:        parser.GetGoType(propSchema),
			JSONName:    propName,
			Description: propSchema.Description,
			Example:     propSchema.Example,
		}

		// Check if field is required
		for _, req := range schema.Required {
			if req == propName {
				field.Required = true
				break
			}
		}

		model.Fields = append(model.Fields, field)
	}

	return model, nil
}

// determineImports determines necessary imports for a model file
func (g *ModelGenerator) determineImports(models []Model) []string {
	importsMap := make(map[string]bool)

	for _, model := range models {
		for _, field := range model.Fields {
			// Add time import if any time.Time fields are present
			if strings.Contains(field.Type, "time.Time") {
				importsMap["time"] = true
			}
		}
	}

	// Convert map to slice
	var imports []string
	for imp := range importsMap {
		imports = append(imports, imp)
	}

	return imports
}

// renderModelFile renders a model file using templates
func (g *ModelGenerator) renderModelFile(modelFile ModelFile) (string, error) {
	// Use a simple template for now
	tmplText := `// Code generated by gopenapi; DO NOT EDIT.
package {{.PackageName}}

import (
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

{{range .Models}}
// {{.Name}} {{.Description}}
type {{.Name}} struct {
{{- range .Fields}}
	// {{.Description}}
	{{.Name}} {{.Type}} ` + "`json:\"{{.JSONName}}{{if not .Required}},omitempty{{end}}\"`" + `
{{- end}}
}
{{end}}
`

	tmpl, err := template.New("model").Parse(tmplText)
	if err != nil {
		return "", fmt.Errorf("error parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, modelFile); err != nil {
		return "", fmt.Errorf("error executing template: %w", err)
	}

	return buf.String(), nil
}

// formatModelName formats a schema name as a Go struct name
func formatModelName(name string) string {
	// Convert to camel case if not already
	return toCamelCase(name)
}

// formatFieldName formats a property name as a Go field name
func formatFieldName(name string) string {
	// Convert to camel case
	return toCamelCase(name)
}

// toCamelCase converts a string to CamelCase
func toCamelCase(s string) string {
	// Split by underscore or dash
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-'
	})

	// Capitalize first letter of each part
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[0:1]) + strings.ToLower(part[1:])
		}
	}

	return strings.Join(parts, "")
}
