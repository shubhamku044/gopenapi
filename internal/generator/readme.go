package generator

import (
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/shubhamku044/gopenapi/internal/models"
	"github.com/shubhamku044/gopenapi/pkg/utils"
)

// GenerateReadme generates a comprehensive README for the project
func GenerateReadme(spec *models.OpenAPISpec, baseDir string, packageName string) error {
	readmeTemplate := `# {{.Title}}

{{.Description}}

**Generated by [gopenapi](https://github.com/shubhamku044/gopenapi)**

## ðŸ—ï¸ Project Structure

This project uses a **clean separation** between generated and user code:

` + "```" + `
{{.PackageName}}/
â”œâ”€â”€ main.go              # Your application entry point (never overwritten)
â”œâ”€â”€ go.mod              # Your go.mod file (never overwritten)
â”œâ”€â”€ handlers/           # ðŸ‘ˆ YOUR CODE GOES HERE
â”‚   â””â”€â”€ api.go         # Implement your business logic here
â”œâ”€â”€ generated/          # ðŸ¤– Generated code (safe to regenerate)
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ interfaces.go  # API interface definitions
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ models.go      # Data models from OpenAPI spec
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ router.go      # HTTP server and routing
â””â”€â”€ README.md           # This file
` + "```" + `

## ðŸš€ Getting Started

### 1. Implement Your Business Logic

Edit ` + "`handlers/api.go`" + ` to implement your API endpoints:

` + "```go" + `
package handlers

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "{{.PackageName}}/generated/api"
    "{{.PackageName}}/generated/models"
)

type APIHandlers struct {
    // Add your dependencies here:
    // db     *sql.DB
    // logger *slog.Logger
    // cache  redis.Client
}

func NewAPIHandlers() api.APIHandlers {
    return &APIHandlers{
        // Initialize your dependencies here
    }
}

{{range .Endpoints}}
// {{.HandlerName}} {{.Comment}}
func (h *APIHandlers) {{.HandlerName}}(c *gin.Context{{.Parameters}}) {
    // TODO: Implement your business logic here
    {{.ExampleImplementation}}
}

{{end}}
` + "```" + `

### 2. Run Your Server

` + "```bash" + `
go mod tidy
go run main.go
` + "```" + `

The server will start on port 8080 (or the port specified in the ` + "`PORT`" + ` environment variable).

### 3. Test Your API

{{range .Endpoints}}
**{{.Method}} {{.Path}}** - {{.Summary}}
` + "```bash" + `
curl -X {{.Method}} http://localhost:8080{{.Path}}{{if eq .Method "POST"}} \
  -H "Content-Type: application/json" \
  -d '{}'{{end}}
` + "```" + `

{{end}}

## ðŸ”„ Updating Your API

When you modify your OpenAPI specification:

1. **Regenerate the code:**
   ` + "```bash" + `
   gopenapi --spec=your-api.yaml --output=. --package={{.PackageName}}
   ` + "```" + `

2. **Your code is preserved:**
   - âœ… ` + "`main.go`" + ` - Your custom main function
   - âœ… ` + "`handlers/`" + ` - Your business logic implementation
   - âœ… ` + "`go.mod`" + ` - Your dependencies

3. **Generated code is updated:**
   - ðŸ”„ ` + "`generated/api/interfaces.go`" + ` - Updated interface definitions
   - ðŸ”„ ` + "`generated/models/models.go`" + ` - Updated data models  
   - ðŸ”„ ` + "`generated/server/router.go`" + ` - Updated routing

## ðŸ“š API Reference

{{range .Endpoints}}
### {{.Method}} {{.Path}}

**{{.Summary}}**

{{if .Description}}{{.Description}}{{end}}

{{if .PathParams}}**Path Parameters:**
{{range .PathParams}}
- ` + "`{{.Name}}`" + ` ({{.Type}}) - {{.Description}}
{{end}}
{{end}}

{{if .RequestBody}}**Request Body:**
` + "```json" + `
{{.RequestBodyExample}}
` + "```" + `
{{end}}

**Response:**
` + "```json" + `
{{.ResponseExample}}
` + "```" + `

---

{{end}}

## ðŸ› ï¸ Development Tips

### Adding Middleware

Modify ` + "`main.go`" + ` to add middleware:

` + "```go" + `
func main() {
    apiHandlers := handlers.NewAPIHandlers()
    srv := server.NewServer(apiHandlers)
    
    // Add middleware to the router
    router := srv.GetRouter()
    router.Use(gin.Logger())
    router.Use(gin.Recovery())
    // Add your custom middleware here
    
    srv.Start(":8080")
}
` + "```" + `

### Error Handling

Use consistent error responses:

` + "```go" + `
func (h *APIHandlers) SomeHandler(c *gin.Context) {
    if err := someOperation(); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Internal server error",
            "message": err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"message": "Success"})
}
` + "```" + `

### Database Integration

Add database dependency in ` + "`handlers/api.go`" + `:

` + "```go" + `
type APIHandlers struct {
    db *sql.DB
}

func NewAPIHandlers(db *sql.DB) api.APIHandlers {
    return &APIHandlers{db: db}
}
` + "```" + `

## ðŸ“– Generated Models

{{range .Models}}
### {{.Name}}

` + "```go" + `
type {{.Name}} struct {
{{range .Fields}}    {{.Name}} {{.Type}} ` + "`json:\"{{.JSONName}}\"`" + `{{if .Description}} // {{.Description}}{{end}}
{{end}}}
` + "```" + `

{{end}}

---

**Happy coding! ðŸŽ‰**

> This README was generated automatically. To customize it, edit the template in your gopenapi generator.
`

	tmpl, err := template.New("readme").Parse(readmeTemplate)
	if err != nil {
		return err
	}

	// Prepare data for the template
	title := "API Server"
	if spec.Info.Title != "" {
		title = spec.Info.Title
	}

	description := "A REST API server generated from OpenAPI specification."
	if spec.Info.Description != "" {
		description = spec.Info.Description
	}

	// Prepare endpoints
	var endpoints []struct {
		Method      string
		Path        string
		HandlerName string
		Summary     string
		Description string
		Comment     string
		Parameters  string
		PathParams  []struct {
			Name        string
			Type        string
			Description string
		}
		RequestBody           bool
		RequestBodyExample    string
		ResponseExample       string
		ExampleImplementation string
	}

	for path, operations := range spec.Paths {
		for method, op := range operations {
			handlerName := utils.ToCamelCase(op.OperationID)

			comment := "handles " + strings.ToUpper(method) + " " + path
			if op.Summary != "" {
				comment = op.Summary
			}

			// Build parameters
			var params []string
			var pathParams []struct {
				Name        string
				Type        string
				Description string
			}
			for _, param := range op.Parameters {
				if param.In == "path" {
					paramType := utils.GetGoType(param.Schema)
					params = append(params, param.Name+" "+paramType)
					pathParams = append(pathParams, struct {
						Name        string
						Type        string
						Description string
					}{
						Name:        param.Name,
						Type:        paramType,
						Description: param.Description,
					})
				}
			}

			paramStr := ""
			if len(params) > 0 {
				paramStr = ", " + strings.Join(params, ", ")
			}

			// Example implementation
			var exampleImpl string
			switch strings.ToUpper(method) {
			case "GET":
				if len(pathParams) > 0 {
					exampleImpl = `// Use path parameter: ` + pathParams[0].Name + `
    c.JSON(http.StatusOK, gin.H{
        "id": ` + pathParams[0].Name + `,
        "data": "your data here",
    })`
				} else {
					exampleImpl = `c.JSON(http.StatusOK, gin.H{
        "data": []interface{}{}, // Return your data here
    })`
				}
			case "POST":
				exampleImpl = `var request models.SomeModel
    if err := c.ShouldBindJSON(&request); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // Process the request...
    
    c.JSON(http.StatusCreated, request)`
			case "PUT":
				exampleImpl = `var request models.SomeModel
    if err := c.ShouldBindJSON(&request); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // Update logic here...
    
    c.JSON(http.StatusOK, request)`
			case "DELETE":
				exampleImpl = `// Delete logic here...
    c.JSON(http.StatusNoContent, nil)`
			default:
				exampleImpl = `c.JSON(http.StatusNotImplemented, gin.H{
        "error": "Not implemented yet",
    })`
			}

			endpoints = append(endpoints, struct {
				Method      string
				Path        string
				HandlerName string
				Summary     string
				Description string
				Comment     string
				Parameters  string
				PathParams  []struct {
					Name        string
					Type        string
					Description string
				}
				RequestBody           bool
				RequestBodyExample    string
				ResponseExample       string
				ExampleImplementation string
			}{
				Method:                strings.ToUpper(method),
				Path:                  path,
				HandlerName:           handlerName,
				Summary:               op.Summary,
				Description:           op.Description,
				Comment:               comment,
				Parameters:            paramStr,
				PathParams:            pathParams,
				RequestBody:           op.RequestBody != nil,
				RequestBodyExample:    `{"key": "value"}`,
				ResponseExample:       `{"message": "success"}`,
				ExampleImplementation: exampleImpl,
			})
		}
	}

	// Prepare models
	var models []struct {
		Name   string
		Fields []struct {
			Name        string
			Type        string
			JSONName    string
			Description string
		}
	}

	for modelName, schema := range spec.Components.Schemas {
		var fields []struct {
			Name        string
			Type        string
			JSONName    string
			Description string
		}

		for fieldName, fieldSchema := range schema.Properties {
			goType := utils.GetGoType(fieldSchema)
			fields = append(fields, struct {
				Name        string
				Type        string
				JSONName    string
				Description string
			}{
				Name:        utils.ToCamelCase(fieldName),
				Type:        goType,
				JSONName:    fieldName,
				Description: fieldSchema.Description,
			})
		}

		models = append(models, struct {
			Name   string
			Fields []struct {
				Name        string
				Type        string
				JSONName    string
				Description string
			}
		}{
			Name:   modelName,
			Fields: fields,
		})
	}

	data := struct {
		Title       string
		Description string
		PackageName string
		Endpoints   []struct {
			Method      string
			Path        string
			HandlerName string
			Summary     string
			Description string
			Comment     string
			Parameters  string
			PathParams  []struct {
				Name        string
				Type        string
				Description string
			}
			RequestBody           bool
			RequestBodyExample    string
			ResponseExample       string
			ExampleImplementation string
		}
		Models []struct {
			Name   string
			Fields []struct {
				Name        string
				Type        string
				JSONName    string
				Description string
			}
		}
	}{
		Title:       title,
		Description: description,
		PackageName: packageName,
		Endpoints:   endpoints,
		Models:      models,
	}

	f, err := os.Create(filepath.Join(baseDir, "README.md"))
	if err != nil {
		return err
	}
	defer f.Close()

	return tmpl.Execute(f, data)
}
