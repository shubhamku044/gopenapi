// routes.go - Generates API routes from OpenAPI paths
package generator

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/shubhamku044/gopenapi/internal/parser"
)

// RouteGenerator generates Go route registration code from OpenAPI paths
type RouteGenerator struct {
	Config Config
}

// RouteFile represents a generated route file
type RouteFile struct {
	PackageName string
	Imports     []string
	Routes      []Route
}

// Route represents a route definition
type Route struct {
	Method      string
	Path        string
	HandlerName string
	HandlerPkg  string
}

// NewRouteGenerator creates a new route generator
func NewRouteGenerator(config Config) *RouteGenerator {
	return &RouteGenerator{
		Config: config,
	}
}

// GenerateRoutes generates Go route registration code from OpenAPI paths
func (g *RouteGenerator) GenerateRoutes(spec *parser.OpenAPISpec) ([]OutputFile, error) {
	var routes []Route

	// Process each path
	for pathURL, pathItem := range spec.Paths {
		// Process each operation (GET, POST, etc.)
		operations := map[string]*parser.Operation{
			"GET":     pathItem.Get,
			"POST":    pathItem.Post,
			"PUT":     pathItem.Put,
			"DELETE":  pathItem.Delete,
			"OPTIONS": pathItem.Options,
			"HEAD":    pathItem.Head,
			"PATCH":   pathItem.Patch,
			"TRACE":   pathItem.Trace,
		}

		for method, operation := range operations {
			if operation == nil {
				continue
			}

			// Determine handler name
			handlerName := operation.OperationID
			if handlerName == "" {
				handlerName = method + toCamelCase(pathURL)
			}
			handlerName = formatHandlerName(handlerName)

			// Determine handler package
			handlerPkg := "handlers"
			if len(operation.Tags) > 0 {
				// We don't use tag for package, just keep it in "handlers"
			}

			route := Route{
				Method:      method,
				Path:        convertPathToGo(pathURL),
				HandlerName: handlerName,
				HandlerPkg:  handlerPkg,
			}

			routes = append(routes, route)
		}
	}

	// Create route file
	routeFile := RouteFile{
		PackageName: "routes",
		Routes:      routes,
	}

	// Add imports
	routeFile.Imports = []string{
		"net/http",
		g.Config.PackageName + "/api/handlers",
	}

	// Generate the file content
	content, err := g.renderRouteFile(routeFile)
	if err != nil {
		return nil, fmt.Errorf("error rendering route file: %w", err)
	}

	return []OutputFile{
		{
			Path:    "api/routes/routes.go",
			Content: content,
		},
	}, nil
}

// renderRouteFile renders a route file using templates
func (g *RouteGenerator) renderRouteFile(routeFile RouteFile) (string, error) {
	// Use a simple template for now
	tmplText := `// Code generated by gopenapi; DO NOT EDIT.
package {{.PackageName}}

import (
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

// RegisterRoutes registers all API routes with the provided router
func RegisterRoutes(router http.Handler) {
	// Type assertion to ensure we have the correct router type
	// This is a simplified example, you'll need to adapt it to your router library
	
	// Example with standard library:
	mux, ok := router.(*http.ServeMux)
	if !ok {
		panic("Router is not *http.ServeMux")
	}

	// Register all routes
	{{range .Routes}}
	mux.HandleFunc("{{.Path}}", func(w http.ResponseWriter, r *http.Request) {
		if r.Method == "{{.Method}}" {
			handlers.{{.HandlerName}}(w, r)
			return
		}
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	})
	{{end}}
}
`

	tmpl, err := template.New("routes").Parse(tmplText)
	if err != nil {
		return "", fmt.Errorf("error parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, routeFile); err != nil {
		return "", fmt.Errorf("error executing template: %w", err)
	}

	return buf.String(), nil
}

// convertPathToGo converts an OpenAPI path to a Go path
func convertPathToGo(path string) string {
	// OpenAPI uses {param} syntax, but Go's http package doesn't use path parameters directly
	// We'll simply remove the curly braces for now
	// In a real implementation, you might want to use a router library like gorilla/mux
	// that supports path parameters
	return path
}
