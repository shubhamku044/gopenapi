// generator.go - Main code generator
package generator

import (
	"github.com/shubhamku044/gopenapi/internal/parser"
)

// Config represents generator configuration
type Config struct {
	PackageName  string
	ServerOnly   bool
	ClientOnly   bool
	TemplatesDir string
}

// OutputFile represents a file to be written
type OutputFile struct {
	Path    string
	Content string
}

// Generate generates code from an OpenAPI specification
func Generate(spec *parser.OpenAPISpec, config Config) ([]OutputFile, error) {
	var files []OutputFile

	// Generate models
	modelGen := NewModelGenerator(config)
	modelFiles, err := modelGen.GenerateModels(spec)
	if err != nil {
		return nil, err
	}
	files = append(files, modelFiles...)

	// Skip client/server generation based on flags
	if !config.ClientOnly {
		// Generate handlers
		handlerGen := NewHandlerGenerator(config, nil) // TODO: Pass models map
		handlerFiles, err := handlerGen.GenerateHandlers(spec)
		if err != nil {
			return nil, err
		}
		files = append(files, handlerFiles...)

		// Generate routes
		routeGen := NewRouteGenerator(config)
		routeFiles, err := routeGen.GenerateRoutes(spec)
		if err != nil {
			return nil, err
		}
		files = append(files, routeFiles...)

		// Generate server
		serverGen := NewServerGenerator(config)
		serverFiles, err := serverGen.GenerateServer(spec)
		if err != nil {
			return nil, err
		}
		files = append(files, serverFiles...)
	}

	if !config.ServerOnly {
		// Generate client code (not implemented in this example)
		// clientGen := NewClientGenerator(config)
		// clientFiles, err := clientGen.GenerateClient(spec)
		// if err != nil {
		//     return nil, err
		// }
		// files = append(files, clientFiles...)
	}

	// Generate README
	readme := generateReadme(spec, config)
	files = append(files, OutputFile{
		Path:    "README.md",
		Content: readme,
	})

	return files, nil
}

// generateReadme generates a README file for the API
func generateReadme(spec *parser.OpenAPISpec, config Config) string {
	title := spec.Info.Title
	if title == "" {
		title = "Generated API"
	}

	description := spec.Info.Description
	if description == "" {
		description = "API generated by gopenapi"
	}

	version := spec.Info.Version
	if version == "" {
		version = "1.0.0"
	}

	return `# ` + title + `

` + description + `

## API Version

` + version + `

## Getting Started

This API was generated using gopenapi from an OpenAPI specification.

### Running the Server

` + "```bash" + `
# Navigate to the server directory
cd cmd/server

# Build the server
go build

# Run the server
./server --port 8080
` + "```" + `

## API Endpoints

` + generateEndpointDocs(spec) + `

## Models

` + generateModelDocs(spec) + `
`
}

// generateEndpointDocs generates documentation for API endpoints
func generateEndpointDocs(spec *parser.OpenAPISpec) string {
	var docs string

	for path, pathItem := range spec.Paths {
		operations := map[string]*parser.Operation{
			"GET":     pathItem.Get,
			"POST":    pathItem.Post,
			"PUT":     pathItem.Put,
			"DELETE":  pathItem.Delete,
			"OPTIONS": pathItem.Options,
			"HEAD":    pathItem.Head,
			"PATCH":   pathItem.Patch,
			"TRACE":   pathItem.Trace,
		}

		for method, operation := range operations {
			if operation == nil {
				continue
			}

			docs += "### " + method + " " + path + "\n\n"

			if operation.Summary != "" {
				docs += operation.Summary + "\n\n"
			}

			if operation.Description != "" {
				docs += operation.Description + "\n\n"
			}

			// Add parameters
			if len(operation.Parameters) > 0 {
				docs += "**Parameters:**\n\n"
				for _, param := range operation.Parameters {
					required := ""
					if param.Required {
						required = " (required)"
					}
					docs += "- `" + param.Name + "` (" + param.In + ")" + required + ": " + param.Description + "\n"
				}
				docs += "\n"
			}

			// Add request body
			if operation.RequestBody != nil {
				docs += "**Request Body:**\n\n"
				docs += "Required: " + boolToString(operation.RequestBody.Required) + "\n\n"
				for contentType := range operation.RequestBody.Content {
					docs += "Content-Type: `" + contentType + "`\n\n"
				}
			}

			// Add responses
			if len(operation.Responses) > 0 {
				docs += "**Responses:**\n\n"
				for code, response := range operation.Responses {
					docs += "- `" + code + "`: " + response.Description + "\n"
				}
				docs += "\n"
			}
		}
	}

	return docs
}

// generateModelDocs generates documentation for API models
func generateModelDocs(spec *parser.OpenAPISpec) string {
	var docs string

	for name, schema := range spec.Components.Schemas {
		docs += "### " + name + "\n\n"

		if schema.Description != "" {
			docs += schema.Description + "\n\n"
		}

		// Add properties
		if len(schema.Properties) > 0 {
			docs += "**Properties:**\n\n"
			for propName, propSchema := range schema.Properties {
				required := ""
				for _, req := range schema.Required {
					if req == propName {
						required = " (required)"
						break
					}
				}

				docs += "- `" + propName + "`" + required + ": " + propSchema.Type
				if propSchema.Format != "" {
					docs += " (" + propSchema.Format + ")"
				}
				if propSchema.Description != "" {
					docs += " - " + propSchema.Description
				}
				docs += "\n"
			}
			docs += "\n"
		}
	}

	return docs
}

// boolToString converts a boolean to a string
func boolToString(b bool) string {
	if b {
		return "Yes"
	}
	return "No"
}
