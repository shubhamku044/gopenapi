// server.go - Generates server code
package generator

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/shubhamku044/gopenapi/internal/parser"
)

// ServerGenerator generates a server for the API
type ServerGenerator struct {
	Config Config
}

// ServerFile represents a generated server file
type ServerFile struct {
	PackageName string
	Imports     []string
	APITitle    string
	APIVersion  string
}

// NewServerGenerator creates a new server generator
func NewServerGenerator(config Config) *ServerGenerator {
	return &ServerGenerator{
		Config: config,
	}
}

// GenerateServer generates server code for the API
func (g *ServerGenerator) GenerateServer(spec *parser.OpenAPISpec) ([]OutputFile, error) {
	// Skip server generation if client-only mode is enabled
	if g.Config.ClientOnly {
		return nil, nil
	}

	serverFile := ServerFile{
		PackageName: "main",
		APITitle:    spec.Info.Title,
		APIVersion:  spec.Info.Version,
		Imports: []string{
			"flag",
			"fmt",
			"log",
			"net/http",
			g.Config.PackageName + "/api/routes",
		},
	}

	// Generate main.go for the server
	mainContent, err := g.renderMainFile(serverFile)
	if err != nil {
		return nil, fmt.Errorf("error rendering main.go: %w", err)
	}

	return []OutputFile{
		{
			Path:    "cmd/server/main.go",
			Content: mainContent,
		},
	}, nil
}

// renderMainFile renders the main server file using templates
func (g *ServerGenerator) renderMainFile(serverFile ServerFile) (string, error) {
	// Use a simple template for the main server file
	tmplText := `// Code generated by gopenapi; DO NOT EDIT.
package {{.PackageName}}

import (
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

func main() {
	// Parse command-line flags
	port := flag.String("port", "8080", "Server port")
	flag.Parse()

	// Create a new router
	mux := http.NewServeMux()

	// Register API routes
	routes.RegisterRoutes(mux)

	// Start the server
	addr := ":" + *port
	fmt.Printf("Starting {{.APITitle}} v{{.APIVersion}} server on %s\n", addr)
	if err := http.ListenAndServe(addr, mux); err != nil {
		log.Fatalf("Server error: %v", err)
	}
}
`

	tmpl, err := template.New("main").Parse(tmplText)
	if err != nil {
		return "", fmt.Errorf("error parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, serverFile); err != nil {
		return "", fmt.Errorf("error executing template: %w", err)
	}

	return buf.String(), nil
}
